import { createDemo } from './demo.mjs';
const content = document.getElementsByClassName('page-content')[0];
content.appendChild(createDemo({
  location: globalThis.location,
  version: "0.0.0",
  base: "// Target //\n\nconst fac = (n) => (n === 0 ? 1 : n * fac(n - 1));\n\nfac(3);\n",
  meta: "// Instrumentation //\n\n/** @type {import(\"../../context.d.ts\").Context} */\nconst {\n  log,\n  aran: { setupile, transpile, retropile, weaveStandard },\n  astring: { generate },\n  acorn: { parse },\n  target,\n} = /** @type {any} */ (globalThis).__context;\n\nconst {\n  eval: evalGlobal,\n  Symbol,\n  Reflect,\n  Reflect: { defineProperty },\n} = globalThis;\n\nconst {\n  WeakMap,\n  Error,\n  String,\n  JSON: { stringify },\n  Object: { entries },\n  undefined,\n} = globalThis;\n\n/**\n * @type {<K extends PropertyKey, V>(\n *   o: {[k in K]?: V},\n * ) => [K, V][]}\n */\nconst listEntry = entries;\n\n/**\n * @type {<X>(\n *   array: ArrayLike<X>,\n * ) => X[]}\n */\nconst copyArraylike = (input) => {\n  const copy = [];\n  const { length } = input;\n  for (let index = 0; index < length; index++) {\n    copy.push(input[index]);\n  }\n  return copy;\n};\n\n/**\n * @typedef {string & {__brand: \"NodeHash\"}} NodeHash\n * @typedef {string & {__brand: \"FilePath\"}} FilePath\n * @typedef {{\n *   Variable: string & {__brand: \"Variable\"},\n *   Label: string & {__brand: \"Label\"},\n *   Specifier: string & {__brand: \"Specifier\"},\n *   Source: string & {__brand: \"Source\"},\n *   Tag: NodeHash,\n * }} Atom\n * @typedef {string & {__brand: \"Indent\"}} Indent\n * @typedef {{__brand: \"Value\"}} Value\n * @typedef {{\n *   current: number,\n *   tagging: WeakMap<Value, number>,\n *   getSymbolKey: (symbol: symbol) => undefined | string,\n * }} Registry\n * @typedef {(\n *   | Exclude<import(\"aran\").StandardAspectKind, (\n *       | \"apply@around\"\n *       | \"construct@around\"\n *       | \"block@declaration-overwrite\"\n *       | \"program-block@before\"\n *       | \"closure-block@before\"\n *       | \"segment-block@before\"\n *     )>\n *   | \"apply@before\"\n *   | \"apply@after\"\n *   | \"construct@before\"\n *   | \"construct@after\"\n * )} TraceKind\n * @typedef {{\n *   type: \"call\",\n *   callee: Value,\n *   that: Value | undefined,\n *   input: Value[],\n * } | {\n *   type: \"intercept\",\n *   target: Value,\n * } | {\n *   type: \"frame\",\n *   bindings: [string, Value][],\n * } | {\n *   type: \"void\",\n * }} TracePayload\n * @typedef {{\n *   kind: TraceKind,\n *   info: null | string,\n *   hash: NodeHash,\n *   data: TracePayload,\n * }} Trace\n */\n\nconst MAX_PRINT_LENGTH = 20;\n\nconst NAME_PADDING = 10;\n\nconst PREFIX = \" \".repeat(NAME_PADDING);\n\nconst BEGIN = \">>\";\nconst END = \"<<\";\nconst CALL = \"->\";\nconst RETURN = \"<-\";\nconst CONSUME = \"--\";\nconst PRODUCE = \"++\";\nconst SUSPEND = \"*>\";\nconst RESUME = \"<*\";\nconst THROW = \"!!\";\nconst BREAK = \"@@\";\n\n/**\n * @type {{[k in TraceKind]: {\n *   name: string,\n *   sort: string,\n * }}}\n */\nconst PARSING = {\n  \"block@setup\": { name: \"setup\", sort: BEGIN },\n  \"block@teardown\": { name: \"teardown\", sort: END },\n  \"block@declaration\": { name: \"enter\", sort: BEGIN },\n  \"segment-block@after\": { name: \"leave\", sort: END },\n  \"closure-block@after\": { name: \"leave\", sort: END },\n  \"program-block@after\": { name: \"leave\", sort: END },\n  \"generator-block@suspension\": { name: \"suspend\", sort: SUSPEND },\n  \"generator-block@resumption\": { name: \"resume\", sort: RESUME },\n  \"block@throwing\": { name: \"throw\", sort: THROW },\n  \"yield@before\": { name: \"yield\", sort: SUSPEND },\n  \"yield@after\": { name: \"resume\", sort: RESUME },\n  \"await@before\": { name: \"await\", sort: SUSPEND },\n  \"await@after\": { name: \"resolve\", sort: RESUME },\n  \"break@before\": { name: \"break\", sort: BREAK },\n  \"eval@before\": { name: \"eval\", sort: CALL },\n  \"eval@after\": { name: \"return\", sort: RETURN },\n  \"apply@before\": { name: \"apply\", sort: CALL },\n  \"apply@after\": { name: \"return\", sort: RETURN },\n  \"construct@before\": { name: \"construct\", sort: CALL },\n  \"construct@after\": { name: \"return\", sort: RETURN },\n  \"primitive@after\": { name: \"primitive\", sort: PRODUCE },\n  \"intrinsic@after\": { name: \"intrinsic\", sort: PRODUCE },\n  \"import@after\": { name: \"import\", sort: PRODUCE },\n  \"closure@after\": { name: \"closure\", sort: PRODUCE },\n  \"read@after\": { name: \"read\", sort: PRODUCE },\n  \"test@before\": { name: \"test\", sort: CONSUME },\n  \"drop@before\": { name: \"drop\", sort: CONSUME },\n  \"export@before\": { name: \"export\", sort: CONSUME },\n  \"write@before\": { name: \"write\", sort: CONSUME },\n};\n\n/**\n * @type {(\n *   registry: Registry,\n *   value: Value,\n * ) => string}\n */\nconst show = (registry, value) => {\n  if (\n    typeof value === \"symbol\" ||\n    typeof value === \"function\" ||\n    (typeof value === \"object\" && value !== null)\n  ) {\n    let tag = registry.tagging.get(value);\n    if (tag === undefined) {\n      tag = registry.current++;\n      try {\n        registry.tagging.set(value, tag);\n      } catch (error) {\n        // TypeError >> new WeakMap([Symbol.for('foo'), 123]);\n        if (typeof value !== \"symbol\") {\n          throw error;\n        }\n        const key = registry.getSymbolKey(value);\n        if (key === undefined) {\n          throw error;\n        }\n        return `<symbol ${stringify(key)}>`;\n      }\n    }\n    return `#${tag}`;\n  } else if (typeof value === \"string\") {\n    const print = stringify(value);\n    return print.length > MAX_PRINT_LENGTH\n      ? `${print.slice(0, MAX_PRINT_LENGTH)}...\"`\n      : print;\n  } else {\n    return String(value);\n  }\n};\n\n/**\n * @type {(\n *   registry: Registry,\n *   payload: TracePayload,\n * ) => string[]}\n */\nconst formatPayload = (registry, payload) => {\n  switch (payload.type) {\n    case \"void\": {\n      return [];\n    }\n    case \"intercept\": {\n      const { target: main } = payload;\n      return [show(registry, main)];\n    }\n    case \"call\": {\n      const { callee, that, input } = payload;\n      const head =\n        show(registry, callee) +\n        (that === undefined ? \"\" : `[this=${show(registry, that)}]`);\n      if (input.length < 4) {\n        return [\n          head + \"(\" + input.map((value) => show(registry, value)).join(\",\"),\n          \")\",\n        ];\n      } else {\n        return [\n          head + \"(\",\n          ...input.map((value) => \"  \" + show(registry, value) + \",\"),\n          \")\",\n        ];\n      }\n    }\n    case \"frame\": {\n      const { bindings } = payload;\n      if (bindings.length < 4) {\n        return [\n          \"{\" +\n            bindings\n              .map(({ 0: key, 1: val }) => key + \": \" + show(registry, val))\n              .join(\", \") +\n            \"}\",\n        ];\n      } else {\n        return [\n          \"{\",\n          ...bindings.map(\n            ({ 0: key, 1: val }) =>\n              \"  \" + key + \": \" + show(registry, val) + \",\",\n          ),\n          \"}\",\n        ];\n      }\n    }\n    default: {\n      throw new Error(`Invalid trace payload type: ${payload}`);\n    }\n  }\n};\n\n/**\n * @type {(\n *  registry: Registry,\n *  indent: Indent,\n *  trace: Trace,\n * ) => string}\n */\nconst format = (registry, indent, { kind, info, data, hash }) => {\n  const { name, sort } = PARSING[kind];\n  const lines = formatPayload(registry, data);\n  return [\n    name.padEnd(NAME_PADDING) +\n      sort +\n      (info === null ? \"\" : \" [\" + info + \"]\") +\n      (lines.length > 0 ? \" \" + lines.shift() : \"\"),\n    ...lines.map((line) => PREFIX + sort + \" \" + line),\n    PREFIX + sort + \" @ \" + hash,\n  ]\n    .map((line) => indent + line)\n    .join(\"\\n\");\n};\n\nconst initial_state = /** @type {Indent} */ (\"\");\n\nconst advice_global_variable = \"__aran_advice__\";\n\nconst weave_config = {\n  pointcut: true,\n  advice_global_variable,\n  initial_state,\n};\n\n/**\n * @type {(\n *   indent: Indent,\n * ) => Indent}\n */\nconst indentRoutine = (indent) => /** @type {Indent} */ (`${indent}|`);\n\n/**\n * @type {(\n *   indent: Indent,\n * ) => Indent}\n */\nconst indentControl = (indent) => /** @type {Indent} */ (`${indent}.`);\n\n/**\n * @type {TracePayload}\n */\nconst VOID = { type: \"void\" };\n\n/**\n * @type {(\n *   weaveStandard: import(\"aran\").weaveStandard,\n *   global: {\n *     Reflect: {\n *       apply: (\n *         callee: Value,\n *         that: Value,\n *         input: Value[],\n *       ) => Value,\n *       construct: (\n *         callee: Value,\n *         input: Value[],\n *       ) => Value,\n *     },\n *     Symbol: {\n *       keyFor: (symbol: symbol) => undefined | string,\n *     },\n *     console: {\n *       log: (message: string) => void,\n *     },\n *   },\n * ) => import(\"aran\").StandardAdvice<Atom & {\n *   Kind: import(\"aran\").StandardAspectKind,\n *   State: Indent,\n *   StackValue: Value,\n *   ScopeValue: Value,\n *   OtherValue: Value,\n * }>}\n */\nconst createTraceAdvice = (\n  weaveStandard,\n  { Reflect: { apply, construct }, Symbol: { keyFor }, console: { log } },\n) => {\n  /** @type {Registry} */\n  const registry = {\n    current: 0,\n    tagging: new WeakMap(),\n    getSymbolKey: keyFor,\n  };\n  let transit_indent = initial_state;\n  return {\n    \"block@setup\": (indent, kind, hash) => {\n      if (\n        kind === \"deep-local-eval\" ||\n        kind === \"arrow\" ||\n        kind === \"function\" ||\n        kind === \"method\" ||\n        kind === \"generator\" ||\n        kind === \"async-arrow\" ||\n        kind === \"async-function\" ||\n        kind === \"async-method\" ||\n        kind === \"async-generator\"\n      ) {\n        indent = indentRoutine(transit_indent);\n      }\n      indent = indentControl(indent);\n      log(\n        format(registry, indent, {\n          kind: \"block@setup\",\n          info: kind,\n          data: VOID,\n          hash,\n        }),\n      );\n      return indent;\n    },\n    \"block@declaration\": (indent, kind, frame, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"block@declaration\",\n          info: kind,\n          data: {\n            type: \"frame\",\n            bindings: listEntry(frame),\n          },\n          hash,\n        }),\n      );\n    },\n    \"block@declaration-overwrite\": (_indent, _kind, frame, _hash) => frame,\n    \"segment-block@before\": (_indent, _kind, _labels, _hash) => {},\n    \"closure-block@before\": (_indent, _kind, _hash) => {},\n    \"program-block@before\": (_indent, _kind, _head, _hash) => {},\n    \"generator-block@suspension\": (indent, kind, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"generator-block@suspension\",\n          info: kind,\n          data: VOID,\n          hash,\n        }),\n      );\n    },\n    \"generator-block@resumption\": (indent, kind, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"generator-block@resumption\",\n          info: kind,\n          data: VOID,\n          hash,\n        }),\n      );\n    },\n    \"segment-block@after\": (indent, kind, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"segment-block@after\",\n          info: kind,\n          data: VOID,\n          hash,\n        }),\n      );\n    },\n    \"closure-block@after\": (indent, kind, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"closure-block@after\",\n          info: kind,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"program-block@after\": (indent, kind, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"program-block@after\",\n          info: kind,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"block@throwing\": (indent, kind, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"block@throwing\",\n          info: kind,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"block@teardown\": (indent, kind, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"block@teardown\",\n          info: kind,\n          data: VOID,\n          hash,\n        }),\n      );\n    },\n    \"break@before\": (indent, label, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"break@before\",\n          info: label,\n          data: VOID,\n          hash,\n        }),\n      );\n    },\n    \"apply@around\": (indent, callee, that, input, hash) => {\n      transit_indent = indent;\n      log(\n        format(registry, indent, {\n          kind: \"apply@before\",\n          info: null,\n          data: {\n            type: \"call\",\n            callee,\n            that,\n            // Prevent pollution from guest realm\n            input: copyArraylike(input),\n          },\n          hash,\n        }),\n      );\n      const result = apply(callee, that, input);\n      log(\n        format(registry, indent, {\n          kind: \"apply@after\",\n          info: null,\n          data: { type: \"intercept\", target: result },\n          hash,\n        }),\n      );\n      return result;\n    },\n    \"construct@around\": (indent, callee, input, hash) => {\n      transit_indent = indent;\n      log(\n        format(registry, indent, {\n          kind: \"construct@before\",\n          info: null,\n          data: {\n            type: \"call\",\n            callee,\n            that: undefined,\n            // Prevent pollution from guest realm\n            input: copyArraylike(input),\n          },\n          hash,\n        }),\n      );\n      const result = construct(callee, input);\n      log(\n        format(registry, indent, {\n          kind: \"construct@after\",\n          info: null,\n          data: { type: \"intercept\", target: result },\n          hash,\n        }),\n      );\n      return result;\n    },\n    \"test@before\": (indent, kind, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"test@before\",\n          info: kind,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"eval@before\": (indent, root, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"eval@before\",\n          info: null,\n          data: { type: \"intercept\", target: root },\n          hash,\n        }),\n      );\n      return /** @type {any} */ (\n        weaveStandard(/** @type {any} */ (root), {\n          pointcut: true,\n          advice_global_variable,\n          initial_state: indent,\n        })\n      );\n    },\n    \"eval@after\": (indent, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"eval@after\",\n          info: null,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"await@before\": (indent, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"await@before\",\n          info: null,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"await@after\": (indent, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"await@after\",\n          info: null,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"yield@before\": (indent, delegate, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"yield@before\",\n          info: delegate ? \"delegate\" : \"normal\",\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"yield@after\": (indent, delegate, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"yield@after\",\n          info: delegate ? \"delegate\" : \"normal\",\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"read@after\": (indent, variable, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"read@after\",\n          info: variable,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"write@before\": (indent, variable, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"write@before\",\n          info: variable,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"drop@before\": (indent, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"drop@before\",\n          info: null,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"export@before\": (indent, specifier, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"export@before\",\n          info: specifier,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"import@after\": (indent, source, specifier, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"import@after\",\n          info: stringify(specifier) + \" from \" + stringify(source),\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"intrinsic@after\": (indent, name, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"intrinsic@after\",\n          info: name,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"primitive@after\": (indent, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"primitive@after\",\n          info: null,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n    \"closure@after\": (indent, kind, value, hash) => {\n      log(\n        format(registry, indent, {\n          kind: \"closure@after\",\n          info: kind,\n          data: { type: \"intercept\", target: value },\n          hash,\n        }),\n      );\n      return value;\n    },\n  };\n};\n\nconst advice = createTraceAdvice(weaveStandard, {\n  Reflect: /** @type {any} */ (Reflect),\n  Symbol,\n  console: { log },\n});\n\ndefineProperty(globalThis, advice_global_variable, { value: advice });\n\n/**\n * @type {import(\"aran\").Digest<{\n *   FilePath: FilePath,\n *   NodeHash: NodeHash,\n * }>}\n */\nconst digest = (_node, node_path, file_path, _kind) =>\n  /** @type {NodeHash} */ (`${file_path}:${node_path}`);\n\nevalGlobal(generate(setupile({})));\n\nevalGlobal(\n  generate(\n    retropile(\n      weaveStandard(\n        transpile(\n          {\n            kind: \"script\",\n            situ: { type: \"global\" },\n            path: /** @type {FilePath} */ (\"main\"),\n            root: parse(target, { ecmaVersion: 2024, sourceType: \"script\" }),\n          },\n          { digest },\n        ),\n        weave_config,\n      ),\n    ),\n  ),\n);\n",
  worker: './worker.mjs',
  header_class: 'wrapper',
}));
